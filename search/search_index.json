{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Galaxy Cube documentation Pre-release version Features 4 high-speed analog outputs 8 low-speed analog outputs 16 digital input/outputs Arbitrary synchronous waveforms Ethernet communication General description The Galaxy Cube is a microscopy hardware controller. Thanks to its arbitrary analog output, it can create the needed waveforms for any device controlled by analog signals, like galvo mirrors. The digital outputs create trigger lines for laser, camera or other digitally-controlled devices. Communication to and from the Galaxy Cube is done through a local network. Simply connect the Cube to the same network as your workstation! With a web browser, you can use the Cube for simple use-cases without need to code anything. For higher modularity needs, an MQTT-based API is accessible, allowing to integrate all the functionalities of the Cube into your existing setup. Production Highlights High-speed analog output Update rate : 1 MHz Voltage range : -5V to +5V. Settling time : ~100ns Able to generate arbitrary functions. Can be used to control galvo mirrors. Low-speed analog output Update rate : 50 kHz Voltage range : 0 to +5V Settling time : 2.5 us (typical) Used for Laser/LED intensity,etc Digital I/Os Update rate : 50 MHz Logic level : 3.3V Used to get and send trigger signals. Easy integration Internal Web server for WebUI Internal MQTT broker Easy-to-use API","title":"Galaxy Cube"},{"location":"#welcome-to-galaxy-cube-documentation","text":"Pre-release version","title":"Welcome to Galaxy Cube documentation"},{"location":"#features","text":"4 high-speed analog outputs 8 low-speed analog outputs 16 digital input/outputs Arbitrary synchronous waveforms Ethernet communication","title":"Features"},{"location":"#general-description","text":"The Galaxy Cube is a microscopy hardware controller. Thanks to its arbitrary analog output, it can create the needed waveforms for any device controlled by analog signals, like galvo mirrors. The digital outputs create trigger lines for laser, camera or other digitally-controlled devices. Communication to and from the Galaxy Cube is done through a local network. Simply connect the Cube to the same network as your workstation! With a web browser, you can use the Cube for simple use-cases without need to code anything. For higher modularity needs, an MQTT-based API is accessible, allowing to integrate all the functionalities of the Cube into your existing setup.","title":"General description"},{"location":"#production-highlights","text":"","title":"Production Highlights"},{"location":"#high-speed-analog-output","text":"Update rate : 1 MHz Voltage range : -5V to +5V. Settling time : ~100ns Able to generate arbitrary functions. Can be used to control galvo mirrors.","title":"High-speed analog output"},{"location":"#low-speed-analog-output","text":"Update rate : 50 kHz Voltage range : 0 to +5V Settling time : 2.5 us (typical) Used for Laser/LED intensity,etc","title":"Low-speed analog output"},{"location":"#digital-ios","text":"Update rate : 50 MHz Logic level : 3.3V Used to get and send trigger signals.","title":"Digital I/Os"},{"location":"#easy-integration","text":"Internal Web server for WebUI Internal MQTT broker Easy-to-use API","title":"Easy integration"},{"location":"contact/","text":"SURICUBE GmbH Meyerhofstra\u00dfe 1 69117 Heidelberg T +49 6221 387-8301 F +49 6221 387-897 info@suricube.de suricube.de Commerzbank Heidelberg \u00b7 IBAN DE61 6724 0039 0190 2840 00 \u00b7 BIC COBADEFFXXX St.-Nr. 32498/77488 SURICUBE GmbH\u00b7 Sitz Heidelberg \u00b7 Amtsgericht Mannheim\u00b7 HRB 734816 \u00b7 GF.: Dr. Martin Haas","title":"Contact"},{"location":"hardware_specs/","text":"Hardware specification Todo Get a better picture ? Analog output details High-speed output 16-bit resolution From -5V to +5V 1 MHz update rate Todo [oscilloscope measurement about 0 to 65535 transition] [ADC calibration / non-linearity] [graph about typical noise ] Low-speed output 16-bit resolution From 0 to 5V 50kHz update rate [graph about 0 to 65535 transition] [graph about noise / non-linearity ?] => how is the non-linearity handled ? Todo [Add plot of low speed DAC output / transition] Digital I/Os details Designed for 50 Ohm impedance. Each connector is either input or output. There is a hardware change required to go from one to the other (soldering a resistor). By default, the Cube comes with 8+4 outputs and 4 inputs. Inputs Accept 3.3V and 5V logic high (and 0V logic low). Minimum detectable pulse time : ~4ns (behavious might be unexpected that close to the limit). Outputs 3.3V logic high - 0V logic low. Minimum pulse width : 4ns ( #ToBeConfirmed) Todo [Add plot of digital I/Os ?]","title":"Hardware specification"},{"location":"hardware_specs/#hardware-specification","text":"Todo Get a better picture ?","title":"Hardware specification"},{"location":"hardware_specs/#analog-output-details","text":"","title":"Analog output details"},{"location":"hardware_specs/#high-speed-output","text":"16-bit resolution From -5V to +5V 1 MHz update rate Todo [oscilloscope measurement about 0 to 65535 transition] [ADC calibration / non-linearity] [graph about typical noise ]","title":"High-speed output"},{"location":"hardware_specs/#low-speed-output","text":"16-bit resolution From 0 to 5V 50kHz update rate [graph about 0 to 65535 transition] [graph about noise / non-linearity ?] => how is the non-linearity handled ? Todo [Add plot of low speed DAC output / transition]","title":"Low-speed output"},{"location":"hardware_specs/#digital-ios-details","text":"Designed for 50 Ohm impedance. Each connector is either input or output. There is a hardware change required to go from one to the other (soldering a resistor). By default, the Cube comes with 8+4 outputs and 4 inputs.","title":"Digital I/Os details"},{"location":"hardware_specs/#inputs","text":"Accept 3.3V and 5V logic high (and 0V logic low). Minimum detectable pulse time : ~4ns (behavious might be unexpected that close to the limit).","title":"Inputs"},{"location":"hardware_specs/#outputs","text":"3.3V logic high - 0V logic low. Minimum pulse width : 4ns ( #ToBeConfirmed) Todo [Add plot of digital I/Os ?]","title":"Outputs"},{"location":"modules_overview/","text":"Modules Here is a quick overview of the internal logic of the Galaxy cube : Analog signal Generator : generates an arbitrary 16-bit signal by iterating over different sections (analytically defined 3rd order polynomial). Digital signal generator : generates an arbitrary digital signal by iterating over different sections. Pulse forwarder : generates digital pulses synchronously to a specified signal generator. External triggering : starts, stops or pauses specified signal generator in case of incoming digital or mqtt input. Signal summer : sums different 16-bit signals together, before they reach the DAC. Digital galvo driver : Additional output for the 16-bit signals. Can drive a xxx-xxx galvomiror. Additional custom hardware is needed. Todo Ask Alejandro exactly which galvo can be driven. Is additional hardware needed ? Slow Dac controller : controls the voltage level (0-5V) of the slow dac outputs.","title":"Capacities overview"},{"location":"modules_overview/#modules","text":"Here is a quick overview of the internal logic of the Galaxy cube : Analog signal Generator : generates an arbitrary 16-bit signal by iterating over different sections (analytically defined 3rd order polynomial). Digital signal generator : generates an arbitrary digital signal by iterating over different sections. Pulse forwarder : generates digital pulses synchronously to a specified signal generator. External triggering : starts, stops or pauses specified signal generator in case of incoming digital or mqtt input. Signal summer : sums different 16-bit signals together, before they reach the DAC. Digital galvo driver : Additional output for the 16-bit signals. Can drive a xxx-xxx galvomiror. Additional custom hardware is needed. Todo Ask Alejandro exactly which galvo can be driven. Is additional hardware needed ? Slow Dac controller : controls the voltage level (0-5V) of the slow dac outputs.","title":"Modules"},{"location":"signal_generation_logic/","text":"Signal generation logic General principle The Signal Generators are based on an integrator design : Output_n = S^0_n \\\\ S^0_{n+1}= S^0_n + \\Delta t * S^1_n \\\\ S^1_{n+1}= S^1_n + \\Delta t * S^2_n \\\\ S^2_{n+1}= S^2_n + \\Delta t * S^3_n \\\\ S^3_{n+1}= S^3_n Note The actual implementation is a bit more complex, as we\u2019re working with (different) finite-bit number representations. We also need to do some unit conversions to take into account the cycle period, and to convert between output voltage and internal number. A very natural way to control the output is to specify Section=(S^0_0, S^1_0, S^2_0, S^3_0, length) and then let the integrator run for a period of time. After a predefined amount of time, we can then give a new set of values, changing the output. This system allows to generate any 3rd degree polynomial , which in turn allows to approximate any waveform. output(t) = \\begin{cases} f(section_0, t) \\text{ for } 0 \\le t < length_0 \\\\ f(section_1, t) \\text{ for } length_0 \\le t < length_1 \\\\ ... \\\\ f(section_{last}, t) \\text{ for } length_{last -1 } \\le t < length_{last} \\\\ \\end{cases} Example Simulation of single sections. The different types of polynomials possible are displayed. The number of a signal is equivalent to it's polynomial degree . Simulation of a signal, consisting of 4 different linear sections. It's repeated once Implementation options In pratice, there are a couple more questions to solve : As the signal is a piecewise function, what kind of continuity should there be between each section? discontinous : at the transition tick, we replace all S^x values with the new ones. C^0 (continous) : S^0 = S^0_{old} , the 3 others values are replaced C^1 (continous and continous first derivative) : (S^0, S^1, S^2, S^3) = (S^0_{old}, S^1_{old}, S^2_{new}, S^3_{new}) C^2 : (S^0, S^1, S^2, S^3) = (S^0_{old}, S^1_{old}, S^2_{old}, S^3_{new}) Instead of only giving one array [ section_0, section_1, section_2, ... ] , we have one array containing all the section definitions, and than the ASG gets an array having pointers to the section and decribing the transition : [(\\text{pointer to section}, \\text{transition type}), (\\text{pointer to section}, \\text{transition type}), ...] . The signal generator then steps through that array, and when it reaches the end starts over. This is especially usefull for reducing memory usage of signals with pattern, like a staircase signal (flat, up, flat, up, ...). In pratical, we might not want infinitely looping signal generators. To more finely control their behaviour, there are 2 mechanisms : internal control : each signal generator counts how many sections and how many periods it already generated. It's possible to configure them so that they stop (or pause ?) after a specified amount. external control : the triggering modules can also send a pause or stop command to the signal generator. Raw vs voltage sections There are 2 ways to define the sections : Raw sections : the values are signed 64-bits numbers, and are sent as-is to the FPGA. Voltage sections : Instead of giving the values for the 4 first derivatives, you select instead the starting point, the ending point, and the slope/ derivative at the start and ending point. You then select which kind of interpolation you would have : constant, linear, quadratic or cubic. The values are converted from Volt , Volt/s, etc\u2026 into the appropriate values for the FPGA - taking into account the DAC calibration and the FPGA clock speed.","title":"Signal generation"},{"location":"signal_generation_logic/#signal-generation-logic","text":"","title":"Signal generation logic"},{"location":"signal_generation_logic/#general-principle","text":"The Signal Generators are based on an integrator design : Output_n = S^0_n \\\\ S^0_{n+1}= S^0_n + \\Delta t * S^1_n \\\\ S^1_{n+1}= S^1_n + \\Delta t * S^2_n \\\\ S^2_{n+1}= S^2_n + \\Delta t * S^3_n \\\\ S^3_{n+1}= S^3_n Note The actual implementation is a bit more complex, as we\u2019re working with (different) finite-bit number representations. We also need to do some unit conversions to take into account the cycle period, and to convert between output voltage and internal number. A very natural way to control the output is to specify Section=(S^0_0, S^1_0, S^2_0, S^3_0, length) and then let the integrator run for a period of time. After a predefined amount of time, we can then give a new set of values, changing the output. This system allows to generate any 3rd degree polynomial , which in turn allows to approximate any waveform. output(t) = \\begin{cases} f(section_0, t) \\text{ for } 0 \\le t < length_0 \\\\ f(section_1, t) \\text{ for } length_0 \\le t < length_1 \\\\ ... \\\\ f(section_{last}, t) \\text{ for } length_{last -1 } \\le t < length_{last} \\\\ \\end{cases}","title":"General principle"},{"location":"signal_generation_logic/#example","text":"Simulation of single sections. The different types of polynomials possible are displayed. The number of a signal is equivalent to it's polynomial degree . Simulation of a signal, consisting of 4 different linear sections. It's repeated once","title":"Example"},{"location":"signal_generation_logic/#implementation-options","text":"In pratice, there are a couple more questions to solve : As the signal is a piecewise function, what kind of continuity should there be between each section? discontinous : at the transition tick, we replace all S^x values with the new ones. C^0 (continous) : S^0 = S^0_{old} , the 3 others values are replaced C^1 (continous and continous first derivative) : (S^0, S^1, S^2, S^3) = (S^0_{old}, S^1_{old}, S^2_{new}, S^3_{new}) C^2 : (S^0, S^1, S^2, S^3) = (S^0_{old}, S^1_{old}, S^2_{old}, S^3_{new}) Instead of only giving one array [ section_0, section_1, section_2, ... ] , we have one array containing all the section definitions, and than the ASG gets an array having pointers to the section and decribing the transition : [(\\text{pointer to section}, \\text{transition type}), (\\text{pointer to section}, \\text{transition type}), ...] . The signal generator then steps through that array, and when it reaches the end starts over. This is especially usefull for reducing memory usage of signals with pattern, like a staircase signal (flat, up, flat, up, ...). In pratical, we might not want infinitely looping signal generators. To more finely control their behaviour, there are 2 mechanisms : internal control : each signal generator counts how many sections and how many periods it already generated. It's possible to configure them so that they stop (or pause ?) after a specified amount. external control : the triggering modules can also send a pause or stop command to the signal generator.","title":"Implementation options"},{"location":"signal_generation_logic/#raw-vs-voltage-sections","text":"There are 2 ways to define the sections : Raw sections : the values are signed 64-bits numbers, and are sent as-is to the FPGA. Voltage sections : Instead of giving the values for the 4 first derivatives, you select instead the starting point, the ending point, and the slope/ derivative at the start and ending point. You then select which kind of interpolation you would have : constant, linear, quadratic or cubic. The values are converted from Volt , Volt/s, etc\u2026 into the appropriate values for the FPGA - taking into account the DAC calibration and the FPGA clock speed.","title":"Raw vs voltage sections"},{"location":"triggers/","text":"Triggers : trigger, pause, stop Reaction times out of stop : 16 ns before next section out of pause from section/period counting : 40 ns before next section out of pause from external trigger : continues where it paused, so ... ?","title":"Triggers"},{"location":"triggers/#triggers-trigger-pause-stop","text":"","title":"Triggers : trigger, pause, stop"},{"location":"triggers/#reaction-times","text":"out of stop : 16 ns before next section out of pause from section/period counting : 40 ns before next section out of pause from external trigger : continues where it paused, so ... ?","title":"Reaction times"},{"location":"usage/","text":"Using the Galaxy Cube Connection the Cube Connect the Cube to the same network as your workstation. By default, the Cube has the following ip address : 192.168.1.111/24 . It has also mDNS enabled, allowing you to connect to it with the following address : fz3.local . If the Cube is successfully connected to the same network as the workstation, you can ping it and remote connect into it through ssh (default username : root ; default password : root ). Take note that the Cube takes some time to fully boot (~2min). During the booting process, it will not respond to any pings or SSH requests, looking as if the device had some network issue. Web interface fz3.local [Work in progress, maybe put a screenshot of it ?] Predefined web apps Some apps with more powerfull capabilities (interactive plots, etc...). Autogenerated UI If you have a JSON command that works for you, but you regurlarly have to change a couple of values inside (e.g. recalibration of the mirrors), then you can use the autogenerated web UI to create a form in the browser where you can type these values, without changing the other settings. Todo if this works, post an example (json command + screenshot) !!! Experimental / prospective This is still work in progress. MQTT interface See (API documentation)[] to see all the different MQTT commands you can send to the Cube. You might have to regenerate or update it. Do this by clicking (here)[]. Because of a bug in the script, you have to click the link twice to make it work.","title":"Usage"},{"location":"usage/#using-the-galaxy-cube","text":"","title":"Using the Galaxy Cube"},{"location":"usage/#connection-the-cube","text":"Connect the Cube to the same network as your workstation. By default, the Cube has the following ip address : 192.168.1.111/24 . It has also mDNS enabled, allowing you to connect to it with the following address : fz3.local . If the Cube is successfully connected to the same network as the workstation, you can ping it and remote connect into it through ssh (default username : root ; default password : root ). Take note that the Cube takes some time to fully boot (~2min). During the booting process, it will not respond to any pings or SSH requests, looking as if the device had some network issue.","title":"Connection the Cube"},{"location":"usage/#web-interface","text":"","title":"Web interface"},{"location":"usage/#fz3local","text":"[Work in progress, maybe put a screenshot of it ?]","title":"fz3.local"},{"location":"usage/#predefined-web-apps","text":"Some apps with more powerfull capabilities (interactive plots, etc...).","title":"Predefined web apps"},{"location":"usage/#autogenerated-ui","text":"If you have a JSON command that works for you, but you regurlarly have to change a couple of values inside (e.g. recalibration of the mirrors), then you can use the autogenerated web UI to create a form in the browser where you can type these values, without changing the other settings. Todo if this works, post an example (json command + screenshot) !!! Experimental / prospective This is still work in progress.","title":"Autogenerated UI"},{"location":"usage/#mqtt-interface","text":"See (API documentation)[] to see all the different MQTT commands you can send to the Cube. You might have to regenerate or update it. Do this by clicking (here)[]. Because of a bug in the script, you have to click the link twice to make it work.","title":"MQTT interface"},{"location":"examples/calibration/","text":"Python communication General idea To start using the Cube with your python code, you'll need an MQTT library for Python. We found that paho-mqtt was very nice and easy to use. Try to connect to the Cube through MQTT and send dummy messages to check if this part is already working. Now you'll need to write the correct message to the cube. Look at the API documentation to determine how it should look like, and what the options are. You can generate the JSON string manually (like in this example code). Probably a better idea (but more work), is to create a python structure which replicates the JSON object to pass, so that you can then serialize it. If you don't want to do this manually, you can try to use the JSON schemas from the API docs and use a datamodel code generator, like this one for pydantic Code Warning The code is only inteded to give a rough idead about how to start working. It is not robust, nor is it up-to-date to the API of the Cube. # -*- coding: utf-8 -*- \"\"\" Created on Mon Mar 13 16:06:50 2023 @author: Sebastian Hambura \"\"\" # %% Communication with the Galaxy Streamer import paho.mqtt.publish as publish import paho.mqtt.client as mqtt import time def raw_value_command(value): command = \\ \"\"\"{ \"name\": \"Name\", \"device\": \"ASG\", \"payload\": { \"cmd\": \"load_raw_sections\", \"config\": { \"sections\": [ { \"s0_0\": \"\"\" + str(value) + \"\"\", \"s1_0\": 0, \"s2_0\": 0, \"s3_0\": 0, \"length\": 100, \"interpolation\": \"cubic\" }, { \"s0_0\": \"\"\" + str(value) + \"\"\", \"s1_0\": 0, \"s2_0\": 0, \"s3_0\": 0, \"length\": 100, \"interpolation\": \"cubic\" } ], \"section_order\": [ { \"number\": 0, \"transition\": \"discontinous\" }, { \"number\": 1, \"transition\": \"discontinous\" }, { \"number\": 0, \"transition\": \"discontinous\" }, { \"number\": 1, \"transition\": \"discontinous\" } ] } } } \"\"\" return command def voltage_value_command(value): command = \\ \"\"\"{ \"name\": \"Name\", \"device\": \"ASG\", \"payload\": { \"cmd\": \"load_voltage_sections\", \"config\": { \"sections\": [ { \"starting_level\": \"\"\" + str(value) + \"\"\", \"starting_derivative\": 0, \"ending_level\": 0, \"ending_derivative\": 0, \"duration_in_ms\": 1, \"interpolation\": \"constant\" }, { \"starting_level\": \"\"\" + str(value) + \"\"\", \"starting_derivative\": 0, \"ending_level\": 0, \"ending_derivative\": 0, \"duration_in_ms\": 1, \"interpolation\": \"constant\" } ], \"section_order\": [ { \"number\": 0, \"transition\": \"discontinous\" }, { \"number\": 1, \"transition\": \"discontinous\" }, { \"number\": 0, \"transition\": \"discontinous\" }, { \"number\": 1, \"transition\": \"discontinous\" } ] } } } \"\"\" return command def start_command(): command = \\ \"\"\" { \"name\": \"Name\", \"device\": \"ASG\", \"payload\":{ \"cmd\": \"start\" } } \"\"\" return command def set_Streamer_raw_value(value): MQTT_topic = \"suricube/galaxy_cube/11/analog_signal_generator\" publish.single(MQTT_topic, payload=raw_value_command(value), hostname=\"192.168.1.111\", port=1884, protocol=mqtt.MQTTv5, client_id=\"Python test\") time.sleep(0.5) publish.single(MQTT_topic, payload=start_command(), hostname=\"192.168.1.111\", port=1884, protocol=mqtt.MQTTv5, client_id=\"Python test\") def set_Streamer_voltage_value(value): MQTT_topic = \"suricube/galaxy_cube/11/analog_signal_generator\" publish.single(MQTT_topic, payload=voltage_value_command(value), hostname=\"192.168.1.111\", port=1884, protocol=mqtt.MQTTv5, client_id=\"Python test\") time.sleep(0.5) publish.single(MQTT_topic, payload=start_command(), hostname=\"192.168.1.111\", port=1884, protocol=mqtt.MQTTv5, client_id=\"Python test\")","title":"Python communication"},{"location":"examples/calibration/#python-communication","text":"","title":"Python communication"},{"location":"examples/calibration/#general-idea","text":"To start using the Cube with your python code, you'll need an MQTT library for Python. We found that paho-mqtt was very nice and easy to use. Try to connect to the Cube through MQTT and send dummy messages to check if this part is already working. Now you'll need to write the correct message to the cube. Look at the API documentation to determine how it should look like, and what the options are. You can generate the JSON string manually (like in this example code). Probably a better idea (but more work), is to create a python structure which replicates the JSON object to pass, so that you can then serialize it. If you don't want to do this manually, you can try to use the JSON schemas from the API docs and use a datamodel code generator, like this one for pydantic","title":"General idea"},{"location":"examples/calibration/#code","text":"Warning The code is only inteded to give a rough idead about how to start working. It is not robust, nor is it up-to-date to the API of the Cube. # -*- coding: utf-8 -*- \"\"\" Created on Mon Mar 13 16:06:50 2023 @author: Sebastian Hambura \"\"\" # %% Communication with the Galaxy Streamer import paho.mqtt.publish as publish import paho.mqtt.client as mqtt import time def raw_value_command(value): command = \\ \"\"\"{ \"name\": \"Name\", \"device\": \"ASG\", \"payload\": { \"cmd\": \"load_raw_sections\", \"config\": { \"sections\": [ { \"s0_0\": \"\"\" + str(value) + \"\"\", \"s1_0\": 0, \"s2_0\": 0, \"s3_0\": 0, \"length\": 100, \"interpolation\": \"cubic\" }, { \"s0_0\": \"\"\" + str(value) + \"\"\", \"s1_0\": 0, \"s2_0\": 0, \"s3_0\": 0, \"length\": 100, \"interpolation\": \"cubic\" } ], \"section_order\": [ { \"number\": 0, \"transition\": \"discontinous\" }, { \"number\": 1, \"transition\": \"discontinous\" }, { \"number\": 0, \"transition\": \"discontinous\" }, { \"number\": 1, \"transition\": \"discontinous\" } ] } } } \"\"\" return command def voltage_value_command(value): command = \\ \"\"\"{ \"name\": \"Name\", \"device\": \"ASG\", \"payload\": { \"cmd\": \"load_voltage_sections\", \"config\": { \"sections\": [ { \"starting_level\": \"\"\" + str(value) + \"\"\", \"starting_derivative\": 0, \"ending_level\": 0, \"ending_derivative\": 0, \"duration_in_ms\": 1, \"interpolation\": \"constant\" }, { \"starting_level\": \"\"\" + str(value) + \"\"\", \"starting_derivative\": 0, \"ending_level\": 0, \"ending_derivative\": 0, \"duration_in_ms\": 1, \"interpolation\": \"constant\" } ], \"section_order\": [ { \"number\": 0, \"transition\": \"discontinous\" }, { \"number\": 1, \"transition\": \"discontinous\" }, { \"number\": 0, \"transition\": \"discontinous\" }, { \"number\": 1, \"transition\": \"discontinous\" } ] } } } \"\"\" return command def start_command(): command = \\ \"\"\" { \"name\": \"Name\", \"device\": \"ASG\", \"payload\":{ \"cmd\": \"start\" } } \"\"\" return command def set_Streamer_raw_value(value): MQTT_topic = \"suricube/galaxy_cube/11/analog_signal_generator\" publish.single(MQTT_topic, payload=raw_value_command(value), hostname=\"192.168.1.111\", port=1884, protocol=mqtt.MQTTv5, client_id=\"Python test\") time.sleep(0.5) publish.single(MQTT_topic, payload=start_command(), hostname=\"192.168.1.111\", port=1884, protocol=mqtt.MQTTv5, client_id=\"Python test\") def set_Streamer_voltage_value(value): MQTT_topic = \"suricube/galaxy_cube/11/analog_signal_generator\" publish.single(MQTT_topic, payload=voltage_value_command(value), hostname=\"192.168.1.111\", port=1884, protocol=mqtt.MQTTv5, client_id=\"Python test\") time.sleep(0.5) publish.single(MQTT_topic, payload=start_command(), hostname=\"192.168.1.111\", port=1884, protocol=mqtt.MQTTv5, client_id=\"Python test\")","title":"Code"},{"location":"examples/step_signal/","text":"Practical example of signal generation Logic Warning This is work in progress. It might be outdated. Our goal is to generate a step pattern, which can then either be used in jigsaw or zigzag mode. The most straightforward way would be to store every step as a section, and to go over the section in sequential order. However, doing this for a larger (say 2048) number of steps is not possible, as the internal memory for a ASG is only 8 kilobytes (~10 sections, and ~4000 section orders) . Todo Evaluate the actual memory for an ASG Instead, what we'll do is to generate one section for each repetitive part of the final trace : a plateau : constant value for a certain time. a step : constant derivative for a short amount of time Then, by using a continous transition for each new section, we can steadily make (quasi-)steps. { \"description\": \"Generated voltage signal\", \"data\": {\"values\": [ {\"time\": 0, \"voltage\": 0, \"trace\": \"target\"}, {\"time\": 1, \"voltage\": 0, \"trace\": \"target\"}, {\"time\": 1, \"voltage\": 1, \"trace\": \"target\"}, {\"time\": 2, \"voltage\": 1, \"trace\": \"target\"}, {\"time\": 2, \"voltage\": 2, \"trace\": \"target\"}, {\"time\": 3, \"voltage\": 2, \"trace\": \"target\"}, {\"time\": 3, \"voltage\": 3, \"trace\": \"target\"}, {\"time\": 4, \"voltage\": 3, \"trace\": \"target\"}, {\"time\": 4, \"voltage\": 4, \"trace\": \"target\"}, {\"time\": 5, \"voltage\": 4, \"trace\": \"target\"}, {\"time\": 5, \"voltage\": 0, \"trace\": \"target\"}, {\"time\": 6, \"voltage\": 0, \"trace\": \"target\"}, {\"time\": 6, \"voltage\": 1, \"trace\": \"target\"}, {\"time\": 7, \"voltage\": 1, \"trace\": \"target\"}, {\"time\": 7, \"voltage\": 2, \"trace\": \"target\"}, {\"time\": 8, \"voltage\": 2, \"trace\": \"target\"}, {\"time\": 8, \"voltage\": 3, \"trace\": \"target\"}, {\"time\": 9, \"voltage\": 3, \"trace\": \"target\"}, {\"time\": 9, \"voltage\": 4, \"trace\": \"target\"}, {\"time\": 0.0, \"voltage\": 0, \"trace\": \"effective\", \"type\":\"0\"}, {\"time\": 0.9, \"voltage\": 0, \"trace\": \"effective\", \"type\":\"1\"}, {\"time\": 1.0, \"voltage\": 1, \"trace\": \"effective\", \"type\":\"0\"}, {\"time\": 1.9, \"voltage\": 1, \"trace\": \"effective\", \"type\":\"1\"}, {\"time\": 2.0, \"voltage\": 2, \"trace\": \"effective\", \"type\":\"0\"}, {\"time\": 2.9, \"voltage\": 2, \"trace\": \"effective\", \"type\":\"1\"}, {\"time\": 3.0, \"voltage\": 3, \"trace\": \"effective\", \"type\":\"0\"}, {\"time\": 3.9, \"voltage\": 3, \"trace\": \"effective\", \"type\":\"1\"}, {\"time\": 4.0, \"voltage\": 4, \"trace\": \"effective\", \"type\":\"0\"}, {\"time\": 4.9, \"voltage\": 4, \"trace\": \"effective\"}, {\"time\": 5.0, \"voltage\": 0, \"trace\": \"effective\"}, {\"time\": 5.9, \"voltage\": 0, \"trace\": \"effective\"}, {\"time\": 6.0, \"voltage\": 1, \"trace\": \"effective\"}, {\"time\": 6.9, \"voltage\": 1, \"trace\": \"effective\"}, {\"time\": 7.0, \"voltage\": 2, \"trace\": \"effective\"}, {\"time\": 7.9, \"voltage\": 2, \"trace\": \"effective\"}, {\"time\": 8.0, \"voltage\": 3, \"trace\": \"effective\"}, {\"time\": 8.9, \"voltage\": 3, \"trace\": \"effective\"}, {\"time\": 9.0, \"voltage\": 4, \"trace\": \"effective\"} ]}, \"layer\": [ { \"mark\": \"line\", \"encoding\": { \"x\": {\"field\": \"time\", \"type\": \"quantitative\"}, \"y\": {\"field\": \"voltage\", \"type\": \"quantitative\"}, \"color\": {\"field\": \"trace\", \"type\": \"nominal\"}, \"strokeDash\": {\"value\": [5,2]} } }, { \"transform\" : [ {\"filter\": \"datum.type > 0\"} ], \"mark\": {\"type\": \"text\", \"angle\": 0, \"dx\": -10, \"dy\":-30, \"fontSize\": 35}, \"encoding\": { \"x\": {\"field\": \"time\", \"type\": \"quantitative\"}, \"y\": {\"field\": \"voltage\", \"type\": \"quantitative\"}, \"text\": {\"value\": \"\u21d8\" } } } ] } This method has 2 potential problems : We wanted to have an 'instant' change of value. To solve this, we need to make use of the fact that the ASG is running faster than the ADC is generating the signal : if it takes 4 ticks for the ADC to change value, and we do our slope in 2 ticks, then the computation is working, and the ADC will never has seen it. If we got some errors while doing floating point arithmetic or rounding, then they would accumulate over time, and we might not get the expected output. To solve this, we do a discontinous section transition at every time we reach the end of our pattern. Todo Need to change some clocking issue in the FPGA code to be actually able to solve 1. Code pub fn generate_steps( max_voltage: f64, min_voltage: f64, step_width_t: f64, // in ms step_number: u64, do_zigzag: bool, calibration: &ASGParameters, ) -> Signal { let step_height = (max_voltage - min_voltage) / (step_number as f64 - 1.0); //let rising_time = calibration.ms_to_ticks(0.005 / 71. * 3.) as i64; // currently set at 3 ticks let rising_time = calibration.ms_to_ticks(0.01) as i64; // currently set at 3 ticks // Constant on the min value let plateau_min_value = VoltageSection { duration_in_ms: step_width_t - calibration.ticks_to_ms(rising_time), // total step time is as given starting_level: min_voltage, starting_derivative: 0.0, ending_level: max_voltage, ending_derivative: 0.0, interpolation: Interpolation::Constant, } .convert_to_raw(calibration); // constant on the max value let plateau_max_value = VoltageSection { duration_in_ms: step_width_t - calibration.ticks_to_ms(rising_time), // total step time is as given starting_level: max_voltage, starting_derivative: 0.0, ending_level: max_voltage, ending_derivative: 0.0, interpolation: Interpolation::Constant, } .convert_to_raw(calibration); let step_up = VoltageSection { // if it's n ticks long, it will have (n-1) steps // so we need to have a steeper slope duration_in_ms: calibration.ticks_to_ms(rising_time - 1), starting_level: 0.0, starting_derivative: 0.0, ending_level: step_height, ending_derivative: 0.0, interpolation: Interpolation::Linear, } .convert_to_raw(calibration) .overwrite_length(rising_time as u64); let step_down = VoltageSection { // if it's n ticks long, it will have (n-1) steps // so we need to have a steeper slope duration_in_ms: calibration.ticks_to_ms(rising_time - 1), starting_level: 0.0, starting_derivative: 0.0, ending_level: -step_height, ending_derivative: 0.0, interpolation: Interpolation::Linear, } .convert_to_raw(calibration) .overwrite_length(rising_time as u64); // For jigsaw pattern : we go from max to min value directly let step_to_min = VoltageSection { duration_in_ms: calibration.ticks_to_ms(rising_time), // Close to actual value so interpolation is correct starting_level: min_voltage, starting_derivative: 0.0, ending_level: 0.0, ending_derivative: 0.0, interpolation: Interpolation::Constant, } .convert_to_raw(calibration) .overwrite_length(rising_time as u64); // If you change the order of the sections, also change the later code ! let sections = vec![ plateau_min_value, // 0 step_up, // 1 step_down, // 2 step_to_min, // 3 plateau_max_value, // 4 ]; // Going up \u2197 - zig zag and jigsaw let section_order_up = vec![ SectionOrder { number: 0, // min_value transition: Transition::Continous, }, SectionOrder { number: 1, // step_up transition: Transition::Continous, }, ] .repeat(step_number as usize - 1); // we do the final step and the transition manually // Going down \u2198 - for zig zag let section_order_down = vec![ SectionOrder { number: 4, // Plateau max value transition: Transition::Continous, }, SectionOrder { number: 2, // step_down transition: Transition::Continous, }, ] .repeat(step_number as usize - 1); // we do the final step and the transition manually // Combining everything into the final signal Signal { sections: sections, section_order: if do_zigzag { // zigzag pattern vec![ section_order_up, vec![ SectionOrder { // Force plateau at max value - Resets rounding error number: 4, transition: Transition::Discontinous, }, SectionOrder { // A step where we don't move number: 3, // step_to_min : constant + continous => no changes transition: Transition::Continous, }, ], section_order_down, vec![ SectionOrder { // Force plateau at min value - Resets rounding error number: 0, transition: Transition::Discontinous, }, SectionOrder { // A step where we don't move number: 3, // step_to_min : constant + continous => no changes transition: Transition::Continous, }, ], ] .concat() } else { // jigsaw pattern [ //Adding missing final plateau, as well as final transition section_order_up, vec![ SectionOrder { // Force plateau at max value number: 4, transition: Transition::Discontinous, }, SectionOrder { // Force step to min value number: 3, transition: Transition::Discontinous, }, ], ] .concat() }, } } Resulting JSON code { \"sections\":[ { \"s0_0\":6434, \"s1_0\":0, \"s2_0\":0, \"s3_0\":0, \"length\":5571, \"interpolation\":\"constant\" }, { \"s0_0\":32696, \"s1_0\":258573883, \"s2_0\":0, \"s3_0\":0, \"length\":143, \"interpolation\":\"linear\" }, { \"s0_0\":32696, \"s1_0\":-258573883, \"s2_0\":0, \"s3_0\":0, \"length\":143, \"interpolation\":\"linear\" }, { \"s0_0\":6434, \"s1_0\":0, \"s2_0\":0, \"s3_0\":0, \"length\":143, \"interpolation\":\"constant\" }, { \"s0_0\":58959, \"s1_0\":0, \"s2_0\":0, \"s3_0\":0, \"length\":5571, \"interpolation\":\"constant\" } ], \"section_order\":[ { \"number\":0, \"transition\":\"continous\" }, { \"number\":1, \"transition\":\"continous\" }, { \"number\":0, \"transition\":\"continous\" }, { \"number\":1, \"transition\":\"continous\" }, { \"number\":0, \"transition\":\"continous\" }, { \"number\":1, \"transition\":\"continous\" }, { \"number\":4, \"transition\":\"discontinous\" }, { \"number\":3, \"transition\":\"discontinous\" } ] }","title":"Signal generation"},{"location":"examples/step_signal/#practical-example-of-signal-generation","text":"","title":"Practical example of signal generation"},{"location":"examples/step_signal/#logic","text":"Warning This is work in progress. It might be outdated. Our goal is to generate a step pattern, which can then either be used in jigsaw or zigzag mode. The most straightforward way would be to store every step as a section, and to go over the section in sequential order. However, doing this for a larger (say 2048) number of steps is not possible, as the internal memory for a ASG is only 8 kilobytes (~10 sections, and ~4000 section orders) . Todo Evaluate the actual memory for an ASG Instead, what we'll do is to generate one section for each repetitive part of the final trace : a plateau : constant value for a certain time. a step : constant derivative for a short amount of time Then, by using a continous transition for each new section, we can steadily make (quasi-)steps. { \"description\": \"Generated voltage signal\", \"data\": {\"values\": [ {\"time\": 0, \"voltage\": 0, \"trace\": \"target\"}, {\"time\": 1, \"voltage\": 0, \"trace\": \"target\"}, {\"time\": 1, \"voltage\": 1, \"trace\": \"target\"}, {\"time\": 2, \"voltage\": 1, \"trace\": \"target\"}, {\"time\": 2, \"voltage\": 2, \"trace\": \"target\"}, {\"time\": 3, \"voltage\": 2, \"trace\": \"target\"}, {\"time\": 3, \"voltage\": 3, \"trace\": \"target\"}, {\"time\": 4, \"voltage\": 3, \"trace\": \"target\"}, {\"time\": 4, \"voltage\": 4, \"trace\": \"target\"}, {\"time\": 5, \"voltage\": 4, \"trace\": \"target\"}, {\"time\": 5, \"voltage\": 0, \"trace\": \"target\"}, {\"time\": 6, \"voltage\": 0, \"trace\": \"target\"}, {\"time\": 6, \"voltage\": 1, \"trace\": \"target\"}, {\"time\": 7, \"voltage\": 1, \"trace\": \"target\"}, {\"time\": 7, \"voltage\": 2, \"trace\": \"target\"}, {\"time\": 8, \"voltage\": 2, \"trace\": \"target\"}, {\"time\": 8, \"voltage\": 3, \"trace\": \"target\"}, {\"time\": 9, \"voltage\": 3, \"trace\": \"target\"}, {\"time\": 9, \"voltage\": 4, \"trace\": \"target\"}, {\"time\": 0.0, \"voltage\": 0, \"trace\": \"effective\", \"type\":\"0\"}, {\"time\": 0.9, \"voltage\": 0, \"trace\": \"effective\", \"type\":\"1\"}, {\"time\": 1.0, \"voltage\": 1, \"trace\": \"effective\", \"type\":\"0\"}, {\"time\": 1.9, \"voltage\": 1, \"trace\": \"effective\", \"type\":\"1\"}, {\"time\": 2.0, \"voltage\": 2, \"trace\": \"effective\", \"type\":\"0\"}, {\"time\": 2.9, \"voltage\": 2, \"trace\": \"effective\", \"type\":\"1\"}, {\"time\": 3.0, \"voltage\": 3, \"trace\": \"effective\", \"type\":\"0\"}, {\"time\": 3.9, \"voltage\": 3, \"trace\": \"effective\", \"type\":\"1\"}, {\"time\": 4.0, \"voltage\": 4, \"trace\": \"effective\", \"type\":\"0\"}, {\"time\": 4.9, \"voltage\": 4, \"trace\": \"effective\"}, {\"time\": 5.0, \"voltage\": 0, \"trace\": \"effective\"}, {\"time\": 5.9, \"voltage\": 0, \"trace\": \"effective\"}, {\"time\": 6.0, \"voltage\": 1, \"trace\": \"effective\"}, {\"time\": 6.9, \"voltage\": 1, \"trace\": \"effective\"}, {\"time\": 7.0, \"voltage\": 2, \"trace\": \"effective\"}, {\"time\": 7.9, \"voltage\": 2, \"trace\": \"effective\"}, {\"time\": 8.0, \"voltage\": 3, \"trace\": \"effective\"}, {\"time\": 8.9, \"voltage\": 3, \"trace\": \"effective\"}, {\"time\": 9.0, \"voltage\": 4, \"trace\": \"effective\"} ]}, \"layer\": [ { \"mark\": \"line\", \"encoding\": { \"x\": {\"field\": \"time\", \"type\": \"quantitative\"}, \"y\": {\"field\": \"voltage\", \"type\": \"quantitative\"}, \"color\": {\"field\": \"trace\", \"type\": \"nominal\"}, \"strokeDash\": {\"value\": [5,2]} } }, { \"transform\" : [ {\"filter\": \"datum.type > 0\"} ], \"mark\": {\"type\": \"text\", \"angle\": 0, \"dx\": -10, \"dy\":-30, \"fontSize\": 35}, \"encoding\": { \"x\": {\"field\": \"time\", \"type\": \"quantitative\"}, \"y\": {\"field\": \"voltage\", \"type\": \"quantitative\"}, \"text\": {\"value\": \"\u21d8\" } } } ] } This method has 2 potential problems : We wanted to have an 'instant' change of value. To solve this, we need to make use of the fact that the ASG is running faster than the ADC is generating the signal : if it takes 4 ticks for the ADC to change value, and we do our slope in 2 ticks, then the computation is working, and the ADC will never has seen it. If we got some errors while doing floating point arithmetic or rounding, then they would accumulate over time, and we might not get the expected output. To solve this, we do a discontinous section transition at every time we reach the end of our pattern. Todo Need to change some clocking issue in the FPGA code to be actually able to solve 1.","title":"Logic"},{"location":"examples/step_signal/#code","text":"pub fn generate_steps( max_voltage: f64, min_voltage: f64, step_width_t: f64, // in ms step_number: u64, do_zigzag: bool, calibration: &ASGParameters, ) -> Signal { let step_height = (max_voltage - min_voltage) / (step_number as f64 - 1.0); //let rising_time = calibration.ms_to_ticks(0.005 / 71. * 3.) as i64; // currently set at 3 ticks let rising_time = calibration.ms_to_ticks(0.01) as i64; // currently set at 3 ticks // Constant on the min value let plateau_min_value = VoltageSection { duration_in_ms: step_width_t - calibration.ticks_to_ms(rising_time), // total step time is as given starting_level: min_voltage, starting_derivative: 0.0, ending_level: max_voltage, ending_derivative: 0.0, interpolation: Interpolation::Constant, } .convert_to_raw(calibration); // constant on the max value let plateau_max_value = VoltageSection { duration_in_ms: step_width_t - calibration.ticks_to_ms(rising_time), // total step time is as given starting_level: max_voltage, starting_derivative: 0.0, ending_level: max_voltage, ending_derivative: 0.0, interpolation: Interpolation::Constant, } .convert_to_raw(calibration); let step_up = VoltageSection { // if it's n ticks long, it will have (n-1) steps // so we need to have a steeper slope duration_in_ms: calibration.ticks_to_ms(rising_time - 1), starting_level: 0.0, starting_derivative: 0.0, ending_level: step_height, ending_derivative: 0.0, interpolation: Interpolation::Linear, } .convert_to_raw(calibration) .overwrite_length(rising_time as u64); let step_down = VoltageSection { // if it's n ticks long, it will have (n-1) steps // so we need to have a steeper slope duration_in_ms: calibration.ticks_to_ms(rising_time - 1), starting_level: 0.0, starting_derivative: 0.0, ending_level: -step_height, ending_derivative: 0.0, interpolation: Interpolation::Linear, } .convert_to_raw(calibration) .overwrite_length(rising_time as u64); // For jigsaw pattern : we go from max to min value directly let step_to_min = VoltageSection { duration_in_ms: calibration.ticks_to_ms(rising_time), // Close to actual value so interpolation is correct starting_level: min_voltage, starting_derivative: 0.0, ending_level: 0.0, ending_derivative: 0.0, interpolation: Interpolation::Constant, } .convert_to_raw(calibration) .overwrite_length(rising_time as u64); // If you change the order of the sections, also change the later code ! let sections = vec![ plateau_min_value, // 0 step_up, // 1 step_down, // 2 step_to_min, // 3 plateau_max_value, // 4 ]; // Going up \u2197 - zig zag and jigsaw let section_order_up = vec![ SectionOrder { number: 0, // min_value transition: Transition::Continous, }, SectionOrder { number: 1, // step_up transition: Transition::Continous, }, ] .repeat(step_number as usize - 1); // we do the final step and the transition manually // Going down \u2198 - for zig zag let section_order_down = vec![ SectionOrder { number: 4, // Plateau max value transition: Transition::Continous, }, SectionOrder { number: 2, // step_down transition: Transition::Continous, }, ] .repeat(step_number as usize - 1); // we do the final step and the transition manually // Combining everything into the final signal Signal { sections: sections, section_order: if do_zigzag { // zigzag pattern vec![ section_order_up, vec![ SectionOrder { // Force plateau at max value - Resets rounding error number: 4, transition: Transition::Discontinous, }, SectionOrder { // A step where we don't move number: 3, // step_to_min : constant + continous => no changes transition: Transition::Continous, }, ], section_order_down, vec![ SectionOrder { // Force plateau at min value - Resets rounding error number: 0, transition: Transition::Discontinous, }, SectionOrder { // A step where we don't move number: 3, // step_to_min : constant + continous => no changes transition: Transition::Continous, }, ], ] .concat() } else { // jigsaw pattern [ //Adding missing final plateau, as well as final transition section_order_up, vec![ SectionOrder { // Force plateau at max value number: 4, transition: Transition::Discontinous, }, SectionOrder { // Force step to min value number: 3, transition: Transition::Discontinous, }, ], ] .concat() }, } }","title":"Code"},{"location":"examples/step_signal/#resulting-json-code","text":"{ \"sections\":[ { \"s0_0\":6434, \"s1_0\":0, \"s2_0\":0, \"s3_0\":0, \"length\":5571, \"interpolation\":\"constant\" }, { \"s0_0\":32696, \"s1_0\":258573883, \"s2_0\":0, \"s3_0\":0, \"length\":143, \"interpolation\":\"linear\" }, { \"s0_0\":32696, \"s1_0\":-258573883, \"s2_0\":0, \"s3_0\":0, \"length\":143, \"interpolation\":\"linear\" }, { \"s0_0\":6434, \"s1_0\":0, \"s2_0\":0, \"s3_0\":0, \"length\":143, \"interpolation\":\"constant\" }, { \"s0_0\":58959, \"s1_0\":0, \"s2_0\":0, \"s3_0\":0, \"length\":5571, \"interpolation\":\"constant\" } ], \"section_order\":[ { \"number\":0, \"transition\":\"continous\" }, { \"number\":1, \"transition\":\"continous\" }, { \"number\":0, \"transition\":\"continous\" }, { \"number\":1, \"transition\":\"continous\" }, { \"number\":0, \"transition\":\"continous\" }, { \"number\":1, \"transition\":\"continous\" }, { \"number\":4, \"transition\":\"discontinous\" }, { \"number\":3, \"transition\":\"discontinous\" } ] }","title":"Resulting JSON code"},{"location":"modules/analog_signal_generator/","text":"Analog signal generators Input Analog sections array: TODO Section order array: TODO Iteration constraints type and value. type determines if the DSG should run continously, pause after a certain number of sections or pause after a certain number of repeats. value determines the number of iterations after which the SG pauses. TODO Output The analog output signal (on a specific channel). Hardware parameters These are values you shouldn't have to touch or change yourself. upshifting downshifting cycles_per_iteration Todo Add a list of all the hardware parameters ?","title":"Analog signal generation"},{"location":"modules/analog_signal_generator/#analog-signal-generators","text":"","title":"Analog signal generators"},{"location":"modules/analog_signal_generator/#input","text":"Analog sections array: TODO Section order array: TODO Iteration constraints type and value. type determines if the DSG should run continously, pause after a certain number of sections or pause after a certain number of repeats. value determines the number of iterations after which the SG pauses. TODO","title":"Input"},{"location":"modules/analog_signal_generator/#output","text":"The analog output signal (on a specific channel).","title":"Output"},{"location":"modules/analog_signal_generator/#hardware-parameters","text":"These are values you shouldn't have to touch or change yourself. upshifting downshifting cycles_per_iteration Todo Add a list of all the hardware parameters ?","title":"Hardware parameters"},{"location":"modules/digital_galvo_driver/","text":"Digital galvomirror driver This is a specific output port designed to drive the xxx-xxx (Hansscanner ?) galvomirror. The port is a HDMI female port, and the signal has to go through another custom board before reaching the device. You can turn this output on or off by configuring the ASG. Currently, the FPGA wires the modules like this : ASG Digital galvomirror output 0 0 1 1 2 2 3 3 Warning This is a different behaviour than the default analog output ! Because of the presence of the signal summers, any ASG 16-bit signal can be forwarded to any DAC and used on any AO-port. As such, AO-0 can be a different signal than DGD-0","title":"Digital galvomirror"},{"location":"modules/digital_galvo_driver/#digital-galvomirror-driver","text":"This is a specific output port designed to drive the xxx-xxx (Hansscanner ?) galvomirror. The port is a HDMI female port, and the signal has to go through another custom board before reaching the device. You can turn this output on or off by configuring the ASG. Currently, the FPGA wires the modules like this : ASG Digital galvomirror output 0 0 1 1 2 2 3 3 Warning This is a different behaviour than the default analog output ! Because of the presence of the signal summers, any ASG 16-bit signal can be forwarded to any DAC and used on any AO-port. As such, AO-0 can be a different signal than DGD-0","title":"Digital galvomirror driver"},{"location":"modules/digital_signal_generator/","text":"Digital signal generator They are based on the analog signal generators, except that their output range is restricted to 1 bit instead of 16 ones. Input Digital sections array : TODO Section order array : TODO Iteration constraints type and value. type determines if the DSG should run continously, pause after a certain number of sections or pause after a certain number of repeats. value determines the number of iterations after which the SG pauses. TODO Output A digital signal, which is forwarded to a digital output channel. Hardware parameters These are values you shouldn't have to touch or change yourself. upshifting downshifting cycles_per_iteration Todo Add a list of all hardware parameters ?","title":"Digital signal generation"},{"location":"modules/digital_signal_generator/#digital-signal-generator","text":"They are based on the analog signal generators, except that their output range is restricted to 1 bit instead of 16 ones.","title":"Digital signal generator"},{"location":"modules/digital_signal_generator/#input","text":"Digital sections array : TODO Section order array : TODO Iteration constraints type and value. type determines if the DSG should run continously, pause after a certain number of sections or pause after a certain number of repeats. value determines the number of iterations after which the SG pauses. TODO","title":"Input"},{"location":"modules/digital_signal_generator/#output","text":"A digital signal, which is forwarded to a digital output channel.","title":"Output"},{"location":"modules/digital_signal_generator/#hardware-parameters","text":"These are values you shouldn't have to touch or change yourself. upshifting downshifting cycles_per_iteration Todo Add a list of all hardware parameters ?","title":"Hardware parameters"},{"location":"modules/external_triggering/","text":"External triggering For each external triggering module, you can control the consequence of an incoming digital trigger: - do nothing - do a pause command - do a stop command - do a resume command","title":"External triggering"},{"location":"modules/external_triggering/#external-triggering","text":"For each external triggering module, you can control the consequence of an incoming digital trigger: - do nothing - do a pause command - do a stop command - do a resume command","title":"External triggering"},{"location":"modules/pulse_forwarder/","text":"Pulse forwarder This module is used to generate triggers synchronous to specified generated signals. Todo add image / simulation / plot of a pulse forwarder working Principle Every signal generator (ASG or DSG) also generated 2 types of pulses : - at each new section - at each new period Theses pulses go into the pulse forwarder, where you can select which one (if any) you want to propagate to the digital output. For more flexibility, you can process the pulses : - only forward every n-th pulse - add a delay to the pulse - strech the pulse (by default it's 4ns long) graph LR In(\"Pulses from the ASG\") --> Selector Selector --> Divider[\"Pulse divider\"] Divider --> Delay[\"Pulse delayer\"] Delay --> Strech[\"Pulse strecher\"] Strech --> out(\"Digital output\") Warning There is no FIFO/Buffer in the processing pipeline. If another pulse arrives while one pulse is still being used (delay or streching), that pulse will get skipped.","title":"Pulse forwarder"},{"location":"modules/pulse_forwarder/#pulse-forwarder","text":"This module is used to generate triggers synchronous to specified generated signals. Todo add image / simulation / plot of a pulse forwarder working","title":"Pulse forwarder"},{"location":"modules/pulse_forwarder/#principle","text":"Every signal generator (ASG or DSG) also generated 2 types of pulses : - at each new section - at each new period Theses pulses go into the pulse forwarder, where you can select which one (if any) you want to propagate to the digital output. For more flexibility, you can process the pulses : - only forward every n-th pulse - add a delay to the pulse - strech the pulse (by default it's 4ns long) graph LR In(\"Pulses from the ASG\") --> Selector Selector --> Divider[\"Pulse divider\"] Divider --> Delay[\"Pulse delayer\"] Delay --> Strech[\"Pulse strecher\"] Strech --> out(\"Digital output\") Warning There is no FIFO/Buffer in the processing pipeline. If another pulse arrives while one pulse is still being used (delay or streching), that pulse will get skipped.","title":"Principle"},{"location":"modules/signal_summer/","text":"Signal summer The signal summer module is a selective sum operator. This module takes as input the 16-bit signals generated by the ASG. The output goes to a (FPGA-wired) specific DAC. By default, it does nothing and just forwards 1 signal to a DAC (example: the signal summer #2 forwards the signal from ASG #2 to the DAC #2 ). Caution The parameters of the signal summer don't reset if you change the ASG signal manually. Keep that in mind, or reset, or else you might have some weird outputs. However, by changing the parameters you can select which input signals should be used to compute the outgoing signal. Internally, each bit of a variable acts as a flag to determine if the corresponding signal should be used : out = \\sum_i{in_i * bit_i} Warning Keep in mind that the summation is done in the 16-bit realm, and not in the voltage realm ! As such, adding 2 \"0V signals\" gives a resulting signal of 5V (or overflowing to -5V).","title":"Signal summer"},{"location":"modules/signal_summer/#signal-summer","text":"The signal summer module is a selective sum operator. This module takes as input the 16-bit signals generated by the ASG. The output goes to a (FPGA-wired) specific DAC. By default, it does nothing and just forwards 1 signal to a DAC (example: the signal summer #2 forwards the signal from ASG #2 to the DAC #2 ). Caution The parameters of the signal summer don't reset if you change the ASG signal manually. Keep that in mind, or reset, or else you might have some weird outputs. However, by changing the parameters you can select which input signals should be used to compute the outgoing signal. Internally, each bit of a variable acts as a flag to determine if the corresponding signal should be used : out = \\sum_i{in_i * bit_i} Warning Keep in mind that the summation is done in the 16-bit realm, and not in the voltage realm ! As such, adding 2 \"0V signals\" gives a resulting signal of 5V (or overflowing to -5V).","title":"Signal summer"},{"location":"modules/slow_dac/","text":"Slow analog output Specify a value (either 0-5V or a 16-bit number) and the corresponding voltage is set on the output. Currently, no dynamic signal generation is possible - though that might be an option if needed.","title":"Slow analog output"},{"location":"modules/slow_dac/#slow-analog-output","text":"Specify a value (either 0-5V or a 16-bit number) and the corresponding voltage is set on the output. Currently, no dynamic signal generation is possible - though that might be an option if needed.","title":"Slow analog output"},{"location":"webUI/ssp/","text":"Simple scanning pattern Output signal Parameters Note This document is hand-made and not generated automatically to the firmware code. To be sure to have the up-to-date version , look at the WebUI or at the API documentation. min_voltage : minimum voltage (in V) - also voltage of lowest step. Applies to both quick and slow step channels. max_voltage : maximum voltage (in V) - also voltage of highest step. Applies to both quick and slow step channels. quick_n_steps : Total number of steps for one period on the quick channel. quick_t_steps : Width of one step, i.e. the time of a step (in ms). zigzag_on_quick : If true, makes a zigzag pattern on the quick channel. slow_n_steps : Total number of steps for one period ont he slow channel. zigzag_on_slow : If true, makes a zigzag pattern on the slow channel. trigger_width_in_ms : The width of the trigger pulse, in ms. Applies to both quick and slow pulse channels. trigger_logic_level : The logic high voltage level of the pulse. Applies to both quick and slow pulse channels. MQTT message Hello world { \"name\": \"Name\", \"device\": \"ASG\", \"payload\": { \"cmd\": \"load_simple_scanning_pattern\", \"config\": { \"min_voltage\": -4.0, \"max_voltage\": 4.0, \"quick_n_steps\": 4, \"quick_t_steps\": 0.1, \"zigzag_on_quick\": false, \"slow_n_steps\": 4, \"zigzag_on_slow\": false, \"trigger_width_in_ms\": 0.02, \"trigger_logic_level\": 3.3 } } } Web interface","title":"Simple scanning pattern"},{"location":"webUI/ssp/#simple-scanning-pattern","text":"","title":"Simple scanning pattern"},{"location":"webUI/ssp/#output-signal","text":"","title":"Output signal"},{"location":"webUI/ssp/#parameters","text":"Note This document is hand-made and not generated automatically to the firmware code. To be sure to have the up-to-date version , look at the WebUI or at the API documentation. min_voltage : minimum voltage (in V) - also voltage of lowest step. Applies to both quick and slow step channels. max_voltage : maximum voltage (in V) - also voltage of highest step. Applies to both quick and slow step channels. quick_n_steps : Total number of steps for one period on the quick channel. quick_t_steps : Width of one step, i.e. the time of a step (in ms). zigzag_on_quick : If true, makes a zigzag pattern on the quick channel. slow_n_steps : Total number of steps for one period ont he slow channel. zigzag_on_slow : If true, makes a zigzag pattern on the slow channel. trigger_width_in_ms : The width of the trigger pulse, in ms. Applies to both quick and slow pulse channels. trigger_logic_level : The logic high voltage level of the pulse. Applies to both quick and slow pulse channels.","title":"Parameters"},{"location":"webUI/ssp/#mqtt-message","text":"Hello world { \"name\": \"Name\", \"device\": \"ASG\", \"payload\": { \"cmd\": \"load_simple_scanning_pattern\", \"config\": { \"min_voltage\": -4.0, \"max_voltage\": 4.0, \"quick_n_steps\": 4, \"quick_t_steps\": 0.1, \"zigzag_on_quick\": false, \"slow_n_steps\": 4, \"zigzag_on_slow\": false, \"trigger_width_in_ms\": 0.02, \"trigger_logic_level\": 3.3 } } }","title":"MQTT message"},{"location":"webUI/ssp/#web-interface","text":"","title":"Web interface"}]}